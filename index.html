<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Preview Centered Zoom (Mobile First)</title>
    <style>
        /* CSS สำหรับคอนเทนเนอร์และรูปภาพพรีวิว */
        .preview-container {
            width: 100%; /* ทำให้คอนเทนเนอร์ปรับตามความกว้างหน้าจอ */
            max-width: 600px; /* จำกัดความกว้างสูงสุดของคอนเทนเนอร์ */
            height: 400px; /* กำหนดความสูงคงที่ของคอนเทนเนอร์ */
            border: 2px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* สำคัญ: ซ่อนส่วนเกินของรูปภาพ */
            position: relative; /* สำหรับการจัดตำแหน่งรูปภาพภายใน */
            margin: 20px auto; /* จัดกึ่งกลางคอนเทนเนอร์ในหน้าจอ */
        }

        .user-image-preview {
            width: 100%;
            height: 100%;
            object-fit: contain; /* ทำให้รูปภาพพอดีกับคอนเทนเนอร์โดยรักษาสัดส่วน */
            display: block; /* ลบช่องว่างใต้รูปภาพ */
            position: absolute; /* เพื่อให้สามารถจัดตำแหน่งด้วย JavaScript */
            top: 0;
            left: 0;
            /* เพิ่ม transition เพื่อให้การซูม/ลากดูราบรื่นขึ้น */
            transition: transform 0.05s ease-out;
            transform-origin: center center; /* จุดหมุน/ย่อขยายที่กึ่งกลางเสมอ */
            cursor: grab; /* เปลี่ยน cursor เมื่อพร้อมลาก */
        }

        .user-image-preview.dragging {
            cursor: grabbing; /* เปลี่ยน cursor เมื่อกำลังลาก */
        }

        /* สไตล์สำหรับปุ่ม */
        button {
            display: block;
            margin: 10px auto;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }

        /* สำหรับ input file */
        input[type="file"] {
            display: block;
            margin: 20px auto;
        }

    </style>
</head>
<body>

    <h1>ปรับแต่งรูปภาพของคุณ</h1>

    <div class="preview-container">
        <img id="userImagePreview" class="user-image-preview" src="" alt="Image Preview" style="display: none;">
    </div>
    <input type="file" id="imageUpload" accept="image/*">
    <button id="resetImage">รีเซ็ตตำแหน่งและซูม</button>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const userImagePreview = document.getElementById('userImagePreview');
        const resetImageButton = document.getElementById('resetImage');

        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX, startY; // สำหรับเมาส์
        let touchStartX, touchStartY; // สำหรับ touch drag
        let initialPinchDistance = 0; // สำหรับ touch zoom

        // ตัวแปรสำหรับขนาดที่เรนเดอร์จริงของรูปภาพ
        // จะถูกคำนวณใหม่ใน updateImagePosition และ resetImagePosition
        let renderedWidth = 0;
        let renderedHeight = 0;

        // เมื่อมีการเลือกไฟล์ภาพ
        imageUpload.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    userImagePreview.src = e.target.result;
                    userImagePreview.style.display = 'block';
                    // ต้องรอให้รูปภาพโหลดเสร็จก่อนจึงจะคำนวณ naturalWidth/Height ได้
                    userImagePreview.onload = () => {
                        resetImagePosition(); // รีเซ็ตตำแหน่งและซูมเมื่อโหลดรูปใหม่
                    };
                };
                reader.readAsDataURL(file);
            } else {
                userImagePreview.style.display = 'none';
                userImagePreview.src = '';
            }
        });

        // ฟังก์ชันสำคัญ: อัปเดตตำแหน่งและการซูมของรูปภาพ
        function updateImagePosition() {
            // คำนวณขนาดที่แท้จริงของรูปภาพหลังจาก object-fit: contain ได้ทำงาน
            const containerWidth = userImagePreview.parentElement.offsetWidth;
            const containerHeight = userImagePreview.parentElement.offsetHeight;
            const imgNaturalWidth = userImagePreview.naturalWidth;
            const imgNaturalHeight = userImagePreview.naturalHeight;

            const containerRatio = containerWidth / containerHeight;
            const imageRatio = imgNaturalWidth / imgNaturalHeight;

            if (imageRatio > containerRatio) {
                // รูปภาพกว้างกว่า (จะเติมความกว้าง)
                renderedWidth = containerWidth;
                renderedHeight = containerWidth / imageRatio;
            } else {
                // รูปภาพสูงกว่า (จะเติมความสูง)
                renderedHeight = containerHeight;
                renderedWidth = containerHeight * imageRatio;
            }

            // คำนวณขอบเขตการลากที่ถูกต้องตามขนาดที่เรนเดอร์จริงและสเกลปัจจุบัน
            const currentDisplayWidth = renderedWidth * scale;
            const currentDisplayHeight = renderedHeight * scale;

            const maxTranslateX = (currentDisplayWidth - containerWidth) / 2;
            const maxTranslateY = (currentDisplayHeight - containerHeight) / 2;

            // ตรวจสอบและจำกัดการลากไม่ให้เกินขอบเขต
            // ตรวจสอบเฉพาะเมื่อรูปภาพมีขนาดใหญ่กว่าคอนเทนเนอร์ในแกนนั้นๆ
            if (currentDisplayWidth > containerWidth) {
                translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, translateX));
            } else {
                translateX = 0; // ถ้าภาพเล็กกว่า ไม่มีการลากในแกน X
            }

            if (currentDisplayHeight > containerHeight) {
                translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, translateY));
            } else {
                translateY = 0; // ถ้าภาพเล็กกว่า ไม่มีการลากในแกน Y
            }

            userImagePreview.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        }

        // ฟังก์ชันสำหรับรีเซ็ตตำแหน่งและการซูม
        function resetImagePosition() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            updateImagePosition(); // อัปเดตตำแหน่งเริ่มต้น
        }

        resetImageButton.addEventListener('click', resetImagePosition);

        /* --- Event listeners สำหรับ Desktop (เมาส์) --- */
        userImagePreview.addEventListener('mousedown', (e) => {
            isDragging = true;
            userImagePreview.classList.add('dragging');
            startX = e.clientX - translateX;
            startY = e.clientY - translateY;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            // ปรับค่า translateX/Y ตามการเคลื่อนที่ของเมาส์
            translateX = e.clientX - startX;
            translateY = e.clientY - startY;
            updateImagePosition(); // อัปเดตตำแหน่ง
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            userImagePreview.classList.remove('dragging');
        });

        // Wheel event สำหรับซูมบน Desktop
        userImagePreview.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = 0.1;
            const oldScale = scale;

            // ตรวจสอบทิศทางของ scroll wheel
            if (e.deltaY < 0) { // ซูมเข้า
                scale += scaleAmount;
            } else { // ซูมออก
                scale -= scaleAmount;
            }

            // จำกัดค่า scale ระหว่าง 1 (ขนาดปกติ) ถึง 3 (ซูม 3 เท่า)
            scale = Math.max(1, Math.min(3, scale));

            // การปรับตำแหน่งเมื่อซูม (เพื่อให้ยึดแกนกลาง)
            // เราไม่จำเป็นต้องปรับ translateX/Y แบบซับซ้อนเมื่อ transform-origin เป็น center center
            // เพราะมันจะซูมจากจุดศูนย์กลางโดยอัตโนมัติ
            updateImagePosition();
        });

        /* --- Event listeners สำหรับ Mobile/Tablet (Touch) --- */
        userImagePreview.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) { // Single touch for dragging
                isDragging = true;
                userImagePreview.classList.add('dragging');
                touchStartX = e.touches[0].clientX - translateX;
                touchStartY = e.touches[0].clientY - translateY;
            } else if (e.touches.length === 2) { // Two touches for pinching (zoom)
                isDragging = false; // ไม่ลากถ้ามีสองนิ้ว
                initialPinchDistance = getPinchDistance(e.touches);
            }
        });

        userImagePreview.addEventListener('touchmove', (e) => {
            e.preventDefault(); // ป้องกันการเลื่อนหน้าจอหลัก

            if (e.touches.length === 1 && isDragging) { // Dragging with one finger
                translateX = e.touches[0].clientX - touchStartX;
                translateY = e.touches[0].clientY - touchStartY;
                updateImagePosition();
            } else if (e.touches.length === 2) { // Pinching (zoom) with two fingers
                const currentPinchDistance = getPinchDistance(e.touches);
                if (initialPinchDistance === 0) { // ป้องกันการหารด้วยศูนย์ถ้าไม่ได้กำหนดค่าเริ่มต้น
                    initialPinchDistance = currentPinchDistance;
                    return;
                }

                const scaleFactor = currentPinchDistance / initialPinchDistance;
                const oldScale = scale;
                scale = Math.max(1, Math.min(3, scale * scaleFactor)); // จำกัดการซูม

                // อัปเดตระยะห่างเริ่มต้นสำหรับการซูมครั้งต่อไป
                initialPinchDistance = currentPinchDistance;

                // ไม่ต้องปรับ translateX/Y ซับซ้อนเพราะ transform-origin เป็น center
                updateImagePosition();
            }
        });

        userImagePreview.addEventListener('touchend', () => {
            isDragging = false;
            userImagePreview.classList.remove('dragging');
            initialPinchDistance = 0; // รีเซ็ตค่าเมื่อยกนิ้ว
        });

        // Helper function for calculating distance between two touches
        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // หากมีการปรับขนาดหน้าต่าง ให้เรียก updateImagePosition ใหม่
        window.addEventListener('resize', () => {
            if (userImagePreview.style.display !== 'none') {
                updateImagePosition();
            }
        });

    </script>

</body>
</html>
