<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Preview Example</title>
    <style>
        /* CSS ที่ปรับปรุงสำหรับ user-image และคอนเทนเนอร์ */
        .preview-container {
            width: 100%; /* หรือขนาดที่คุณต้องการสำหรับคอนเทนเนอร์ */
            max-width: 600px; /* สมมติว่าต้องการสูงสุด 600px */
            height: 400px; /* หรือขนาดที่คุณต้องการสำหรับคอนเทนเนอร์ */
            border: 2px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* สำคัญเพื่อให้รูปภาพไม่เกินขอบ */
            position: relative;
        }

        .user-image-preview {
            width: 100%;
            height: 100%;
            object-fit: contain; /* ทำให้รูปภาพพอดีกับคอนเทนเนอร์โดยรักษาสัดส่วน */
            display: block; /* ลบช่องว่างใต้รูปภาพ */
            position: absolute; /* เพื่อให้สามารถจัดตำแหน่งด้วย JavaScript ได้ */
            top: 0;
            left: 0;
            transform-origin: center center; /* ตั้งจุดหมุน/ย่อขยายที่กึ่งกลาง */
        }

        /* CSS อื่นๆ ที่คุณมีอยู่แล้ว */
        /* ... */
    </style>
</head>
<body>

    <h1>Your Image Uploader</h1>

    <div class="preview-container">
        <img id="userImagePreview" class="user-image-preview" src="" alt="Image Preview" style="display: none;">
        <input type="file" id="imageUpload" accept="image/*">
    </div>

    <button id="resetImage">Reset Position</button>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const userImagePreview = document.getElementById('userImagePreview');
        const resetImageButton = document.getElementById('resetImage');

        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX, startY;

        imageUpload.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    userImagePreview.src = e.target.result;
                    userImagePreview.style.display = 'block';
                    resetImagePosition(); // รีเซ็ตตำแหน่งทุกครั้งที่เปลี่ยนรูป
                };
                reader.readAsDataURL(file);
            } else {
                userImagePreview.style.display = 'none';
                userImagePreview.src = '';
            }
        });

        // --- เริ่มต้นส่วนแก้ไข JavaScript ที่สำคัญ ---
        function updateImagePosition() {
            // คำนวณขนาดที่แท้จริงของรูปภาพหลังจาก object-fit: contain
            const imgNaturalWidth = userImagePreview.naturalWidth;
            const imgNaturalHeight = userImagePreview.naturalHeight;
            const containerWidth = userImagePreview.parentElement.offsetWidth;
            const containerHeight = userImagePreview.parentElement.offsetHeight;

            let renderedWidth, renderedHeight;
            const containerRatio = containerWidth / containerHeight;
            const imageRatio = imgNaturalWidth / imgNaturalHeight;

            if (imageRatio > containerRatio) {
                // รูปภาพกว้างกว่าเมื่อเทียบกับคอนเทนเนอร์ (จะเติมความกว้าง)
                renderedWidth = containerWidth;
                renderedHeight = containerWidth / imageRatio;
            } else {
                // รูปภาพสูงกว่าเมื่อเทียบกับคอนเทนเนอร์ (จะเติมความสูง)
                renderedHeight = containerHeight;
                renderedWidth = containerHeight * imageRatio;
            }

            // คำนวณขอบเขตการลากที่ถูกต้องตามขนาดที่เรนเดอร์จริง
            const maxTranslateX = (renderedWidth * scale - containerWidth) / 2;
            const maxTranslateY = (renderedHeight * scale - containerHeight) / 2;

            // ตรวจสอบและจำกัดการลากไม่ให้เกินขอบเขต
            translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, translateX));
            translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, translateY));

            userImagePreview.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        }
        // --- สิ้นสุดส่วนแก้ไข JavaScript ที่สำคัญ ---


        function resetImagePosition() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            updateImagePosition(); // ใช้ฟังก์ชันที่แก้ไขแล้ว
        }

        resetImageButton.addEventListener('click', resetImagePosition);

        // Event listeners สำหรับการลากและซูม (ยังคงเหมือนเดิม)
        userImagePreview.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX - translateX;
            startY = e.clientY - translateY;
            userImagePreview.style.cursor = 'grabbing';
        });

        userImagePreview.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            translateX = e.clientX - startX;
            translateY = e.clientY - startY;
            updateImagePosition();
        });

        userImagePreview.addEventListener('mouseup', () => {
            isDragging = false;
            userImagePreview.style.cursor = 'grab';
        });

        userImagePreview.addEventListener('mouseleave', () => {
            isDragging = false;
            userImagePreview.style.cursor = 'grab';
        });

        userImagePreview.addEventListener('wheel', (e) => {
            e.preventDefault();
            const scaleAmount = 0.1;
            const oldScale = scale;
            if (e.deltaY < 0) {
                scale += scaleAmount; // Zoom in
            } else {
                scale -= scaleAmount; // Zoom out
            }
            scale = Math.max(1, Math.min(3, scale)); // จำกัดการซูมระหว่าง 1x ถึง 3x

            // ปรับตำแหน่งเพื่อให้ซูมเข้า/ออกจากจุดที่เมาส์อยู่
            const rect = userImagePreview.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            translateX -= (mouseX - renderedWidth / 2) * (scale - oldScale);
            translateY -= (mouseY - renderedHeight / 2) * (scale - oldScale);

            updateImagePosition();
        });

        // สำหรับมือถือ (touch events)
        let touchStartX, touchStartY;
        let initialPinchDistance = 0;

        userImagePreview.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                touchStartX = e.touches[0].clientX - translateX;
                touchStartY = e.touches[0].clientY - translateY;
            } else if (e.touches.length === 2) {
                initialPinchDistance = getPinchDistance(e.touches);
            }
        });

        userImagePreview.addEventListener('touchmove', (e) => {
            e.preventDefault(); // ป้องกันการเลื่อนหน้าจอ
            if (e.touches.length === 1 && isDragging) {
                translateX = e.touches[0].clientX - touchStartX;
                translateY = e.touches[0].clientY - touchStartY;
                updateImagePosition();
            } else if (e.touches.length === 2) {
                const currentPinchDistance = getPinchDistance(e.touches);
                const scaleFactor = currentPinchDistance / initialPinchDistance;
                const oldScale = scale;
                scale = Math.max(1, Math.min(3, scale * scaleFactor)); // จำกัดการซูม

                // ปรับตำแหน่งเมื่อซูมด้วย pinch
                const rect = userImagePreview.getBoundingClientRect();
                const touch1X = e.touches[0].clientX - rect.left;
                const touch1Y = e.touches[0].clientY - rect.top;

                translateX -= (touch1X - renderedWidth / 2) * (scale - oldScale);
                translateY -= (touch1Y - renderedHeight / 2) * (scale - oldScale);

                initialPinchDistance = currentPinchDistance; // อัปเดตระยะห่างเริ่มต้น
                updateImagePosition();
            }
        });

        userImagePreview.addEventListener('touchend', () => {
            isDragging = false;
            initialPinchDistance = 0;
        });

        function getPinchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // ตัวแปร global สำหรับ renderedWidth และ renderedHeight (ถ้าคุณมีในโค้ดเดิม)
        // หรือให้แน่ใจว่ามันถูกกำหนดค่าใน updateImagePosition() เท่านั้น
        let renderedWidth = 0;
        let renderedHeight = 0;


    </script>

</body>
</html>
